// This code was autogenerated with `dbus-codegen-rust --system-bus --generic-variant --methodtype None --destination org.freedesktop.UPower --skipprefix org.freedesktop --interfaces org.freedesktop.UPower --path /org/freedesktop/UPower`, see https://github.com/diwic/dbus-rs
use dbus as dbus;
use dbus::arg;
use dbus::blocking;

pub trait UPower {
    fn enumerate_devices(&self) -> Result<Vec<dbus::Path<'static>>, dbus::Error>;
    fn get_display_device(&self) -> Result<dbus::Path<'static>, dbus::Error>;
    fn get_critical_action(&self) -> Result<String, dbus::Error>;
    fn daemon_version(&self) -> Result<String, dbus::Error>;
    fn on_battery(&self) -> Result<bool, dbus::Error>;
    fn lid_is_closed(&self) -> Result<bool, dbus::Error>;
    fn lid_is_present(&self) -> Result<bool, dbus::Error>;
}

impl<'a, C: ::std::ops::Deref<Target=blocking::Connection>> UPower for blocking::Proxy<'a, C> {

    fn enumerate_devices(&self) -> Result<Vec<dbus::Path<'static>>, dbus::Error> {
        self.method_call("org.freedesktop.UPower", "EnumerateDevices", ())
            .and_then(|r: (Vec<dbus::Path<'static>>, )| Ok(r.0, ))
    }

    fn get_display_device(&self) -> Result<dbus::Path<'static>, dbus::Error> {
        self.method_call("org.freedesktop.UPower", "GetDisplayDevice", ())
            .and_then(|r: (dbus::Path<'static>, )| Ok(r.0, ))
    }

    fn get_critical_action(&self) -> Result<String, dbus::Error> {
        self.method_call("org.freedesktop.UPower", "GetCriticalAction", ())
            .and_then(|r: (String, )| Ok(r.0, ))
    }

    fn daemon_version(&self) -> Result<String, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.UPower", "DaemonVersion")
    }

    fn on_battery(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.UPower", "OnBattery")
    }

    fn lid_is_closed(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.UPower", "LidIsClosed")
    }

    fn lid_is_present(&self) -> Result<bool, dbus::Error> {
        <Self as blocking::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.UPower", "LidIsPresent")
    }
}

#[derive(Debug)]
pub struct UPowerDeviceAdded {
    pub device: dbus::Path<'static>,
}

impl arg::AppendAll for UPowerDeviceAdded {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.device, i);
    }
}

impl arg::ReadAll for UPowerDeviceAdded {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UPowerDeviceAdded {
            device: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UPowerDeviceAdded {
    const NAME: &'static str = "DeviceAdded";
    const INTERFACE: &'static str = "org.freedesktop.UPower";
}

#[derive(Debug)]
pub struct UPowerDeviceRemoved {
    pub device: dbus::Path<'static>,
}

impl arg::AppendAll for UPowerDeviceRemoved {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.device, i);
    }
}

impl arg::ReadAll for UPowerDeviceRemoved {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(UPowerDeviceRemoved {
            device: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for UPowerDeviceRemoved {
    const NAME: &'static str = "DeviceRemoved";
    const INTERFACE: &'static str = "org.freedesktop.UPower";
}
